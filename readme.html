<html>
    <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <link href="https://fonts.googleapis.com/css?family=PT+Serif:400,400italic,700,700italic" rel="stylesheet" type="text/css" />
    <link href="https://fonts.googleapis.com/css?family=Syncopate" rel="stylesheet" type="text/css" />
    <link type="text/css" rel="stylesheet" href="styles.css" />
    <link href="prism.css" rel="stylesheet" />
    <title data-id="blog-title">Priya’s Blog</title>
</head>

<body>

    <div class="nav">
        <ul>
            <li class="home"><a href="http://priya121.github.io/priyas-blog/index.html">Home</a></li>
            <li class="news"><a class="active" href="#">News</a></li>
            <li class="old_blog"><a href="https://priyapatil101.wordpress.com/">OldBlog</a></li>
            <li class="100days"><a href="http://priya121.github.io/100days/">100days</a></li>
        </ul>
    </div>


    <header id="top">
    <h1><a href="index.html" data-id="blog-title">Priya’s Blog</a></h1>
    <ul>
        <li data-id="if-exists" data-key="twitter">
        <a href="" data-id="href" data-key="twitter">
            <img src="tw.png" width="24" height="20" />
        </a>
        </li>
        
    </ul>
    </header>


    <main>

    <ol class="entries" data-id="page-list" data-max-pages="5">
        <li class="entries">
        <article>
        <header>
        <h2><a class="entries" data-id="page-link" href="patterns.html">Patterns and Anti-Patterns</a></h2>
        <p class="date" data-id="published-at" data-format="dd MMMM yyyy">02 February 2016</p>
        </header>
        <div data-id="content"><p>One thing I am sure of is that there a lot of patterns in code. I am able to recognize some these patterns when we go through them in Zagaku or read about them in simple terms, but when things get more complex I have a bit of a hard time. This is probably because the examples given are purposefully simple and it is clear what the pattern is trying to achieve in the code.</p><p>I think I’d also have a harder time trying to actively incorporate them into my own code or spot them in a complex code base. So, in order to improve on this, one of my stories this week is to read the first part of Implementation Patterns by Kent Back and try and actively incorporate the patterns mentioned into my code.</p><p>I think now is a good time to do this, because my Java Tic Tac Toe is starting to get quite big, and I feel like it definitely needs some cleaning up as I am starting to loose track of the file stucture. This is probably normal when you start working on larger programs and systems, but it isn’t something I’m that used to.</p><p>I’m starting to read about the simple class patterns he discusses, but I thought one of the underlying principles he talks about is quite interesting. He writes that you should keep the consequances local. This, he says, is one of the underlying principles of most of the other patterns. It makes sense because if you are trying to build something complex that needs to change, having tiny bits of functionality you can swap out is a really good idea.</p><p>I know I’ve fallen into a few problems where I have a variable that is not within a method and so is not updated at the right point in time, so this is something I should really try and be more aware of.</p><p>Keeping things that change together (and at the same rate) in the same place is another principle he mentions in the book. The best way to do this is also to probably break things down into small pieces that logically belong together. I have fallen into the trap of making some field variables in my Tic Tac Toe that probably do not need to be field varibles so I am going to start there. I hope that the first step to being able to use patterns is maybe by spotting anti-patterns, but maybe that is just hopeful because I am sure I am following quite a few of those!</p></div>
        </article>
        </li><li class="entries">
        <article>
        <header>
        <h2><a class="entries" data-id="page-link" href="collecting_with_streams.html">Building a collection</a></h2>
        <p class="date" data-id="published-at" data-format="dd MMMM yyyy">01 February 2016</p>
        </header>
        <div data-id="content"><p>Woah, I just got a beast of an error message from my stream method and have no idea what it means. I suppose this is another disadvantage of using something new, when something goes wrong, it is harder to understand why at first.</p><p>Anyway, it wasn’t the streams fault, but something else in my code so crisis averted (kind of).</p><p>I wanted to look at Collectors more today, starting by looking at the built in collectors and then maybe making my own.</p><p>Collectors are useful for creating a list out of the elements of a stream. I have already used .collect(toList()); quite a lot, but some other really useful collectors are ones you can use for Integers:</p><pre>
 <code class="language-java">
      int total = groceries.stream()
                       .collect(Collectors.summingInt(GroceryItem::getPrice)));
</code> 
</pre>
<p>There is also .counting() that increments by the number of input elements, and .averagingInt() that like .summingInt() above aggregates the elements and then performs the operation sequentially on them, this time returning the average of the elements. These operations are also available for Doubles and Longs.</p><p>.joining() concatenates the elements into a String in the order they are processed and can take a delimiter (how the elements are joined together), a prefix and a suffix as arguments. If you don’t give a prefix and suffix the only argument required is the delimiter.</p><pre>
 <code class="language-java">
     String invitation = guests.stream()
      .filter(p -&gt; p.address == "18 Cedar Way")
      .map(p -&gt; p.name)
      .collect(Collectors.joining(" and ", "Hi ", "! You are invited to the party.");
 </code> 
</pre>
<p>This would produce: Hi, Luda and Tom! You are invited to the party.  (Assuming Luda and Tom were two of the Person objects within the Stream of guests, each having instance variables of an address and name).</p><p><a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Collectors.html#toMap-java.util.function.Function-java.util.function.Function-">.toMap()</a> is another useful one that allows you to change the elements of the stream into a map.</p><p>All of these collectors are predefined but it is possible to build your own collector using Collector.of() These take a supplier, combiner, accumulator and finsher.</p><p>The interface of a Collector starts with Collector&lt;T, A, R&gt;:</p><p>This means a Collector accepts items of type T and produces aggregated/accumulated (A) values of the return type R.</p><p>Here is an example:</p><pre>
 <code class="language-java">
   Collector&lt;Guest, StringJoiner, String&gt; guestList =
    Collector.of(
         () -&gt; new StringJoiner(" , "),
         (list, guest) -&gt; list.add(guest.name),
         (list1, list2) -&gt; list1.merge(list2),
         StringJoiner::toString);
</code> 
</pre>
<p>The first part (the supplier) of this Collector is the supplier that creates a new immutable set, which is an unchangeable list of unique elements.</p><p>The second part (the accumulator) of this is accumulation of elements of type T to the immutable set (the new StringJoiner(“ , “)), it’s called list here.</p><p>The third part (the combiner) joins or merges the elements together one by one.</p><p>Finally the fourth part (the finisher) returns the immutable set as the return type you specify.</p><p>When names is returned or printed to the console within a function it should produce a list of names of the Guest objects as a String, joined by a comma.</p><pre>
  <code class="language-java">
   String names = guests
.stream()
    .collect(guestList);
</code> 
</pre>
<p>So that is how you build your a simple collector. There are also .flatmap() and .reduce() which I should probably look into, but not I have put off integrating streams into my TicTacToe when determining rows and columns enough so should probably do that first. Creating your own collection is probably more useful for when things get complex, but for now I am going to stick to using the predefined collectors.</p></div>
        </article>
        </li><li class="entries">
        <article>
        <header>
        <h2><a class="entries" data-id="page-link" href="streams_two.html">Mapping through streams</a></h2>
        <p class="date" data-id="published-at" data-format="dd MMMM yyyy">29 January 2016</p>
        </header>
        <div data-id="content"><p>I’m not sure if you can actually say mapping through streams, but .map() is another useful intermediate operation you can use on the Stream class. Simple sequential streams using .stream() to create a list of elements are relatively straightforward and once you have filtered the data you want to act on, it is also quite simple to use the .map() operation to manipulate the data. .map() allows you to apply a function to elements in the stream.</p><p>Here is an example of this:</p><pre>
<code class="language-java">
Stream&lt;String&gt; map = names.stream()
        .filter(name -&gt; name.startsWith("p"))
                .map(String::toUpperCase);
</code>
</pre>
<p>In this example .map() converts each of the names starting with p in the list of names to a capital P.</p><p>As nothing has been explicitly returned yet, a terminal operation is neccesary, and here the .collect() operation can be used again.</p><pre>
<code class="language-java">
List&lt;String&gt; map = names.stream()
.filter(name -&gt; name.startsWith("p"))
.map(String::toUpperCase);
.collect(toList());
</code>
</pre>
<p>(Another useful way to map through a stream is to use .mapToInt(), which converts primitive ints to Integer objects, and .mapToObj() which converts primitives to Objects).</p><p>The syntax of streams looks a bit strange at the moment, but I suppose I’m just used to regular old for loops. I think I’m starting to see that the basic stream operations are actually relatively straightforward. I’m sure they are going to get much more complicated as I try and apply them more, but hopefully it’s just a case of getting used to the syntax and the way they look.</p></div>
        </article>
        </li><li class="entries">
        <article>
        <header>
        <h2><a class="entries" data-id="page-link" href="streams.html">Streams</a></h2>
        <p class="date" data-id="published-at" data-format="dd MMMM yyyy">28 January 2016</p>
        </header>
        <div data-id="content"><p>I started to introduce streams into my TicTacToe last week and even though the basic operations seem pretty straightforward, I need to understand the details of what is going on and so one of my stories this week is to write a series of blog posts on Java 8 Streams. So here it goes!</p><p>A stream represents a sequence of elements and there are a series of operations that can be performed on them. These operations can be intermediate (which require a terminal operation to be called after them) or terminal (which return a non-stream or void result).</p><p>Most stream operations accept a lambda expression as a parameter.</p><p>A lambda expression is a function which can exist without belonging to a class. They are similar to anonymous inner classes in Java (which are classes that do not have a class name and are instantiated and declared at the same time).</p><p>Here is an example of very simple a lambda expression:</p><p>(int x, int y) -&gt; x + y)</p><p>The expression is divided into three parts: The argument list, the arrow token and the body.</p><p>So, back to streams. A stream represents a list of object references, there are also streams that represent primitives like IntStream, DoubleStream, LongStream. Stream operations are chained together into pipelines.</p><p>The first stream I implemented was to repace the loop I had that checked the valid moves (represented by empty cells) on the board. Previously I was using this for loop to find all the empty cells on my board:</p><pre>
<code class="language-java">
public List&lt;Integer&gt; validMoves() {
        List&lt;Integer&gt; validMoves = new ArrayList&lt;Integer&gt;();
        for (int i = 0; i &lt; board.size(); i++) {
            if (board.get(i).equals(empty)) {
                            validMoves.add(i);
            }
        }
                return validMoves;
}
</code>
</pre>
<p>But I have now introduced this stream:</p><pre>
<code class="language-java">
public List&lt;Integer&gt; validMoves() {
    List&lt;Integer&gt; validMoves =
        IntStream.range(0, this.board.size()).boxed()
        .filter(index -&gt; this.board.get(index).equals(E))
        .collect(toList());
    return validMoves;
}
</code>
</pre>
<p>IntStream streams through a list of indices from 0 to the total size of the board. Calling .boxed() converts the IntStream into a Stream. .filter() then filters through the board and takes the arguement index and using a lambda expression applies it to the .get() method I have for my board.</p><p>Because this is an intermediate operation, without something following the .filter() nothing will be returned. This is why .collect(toList()) is needed. .collect() allows you to convert a stream into another type of result, in my case a list.</p><p>The operation .collect() accepts a Collector and there are many useful collectors, the one I have used is toList(), there are also many other useful ones like .groupingBy(), .averagingInt() etc. It is also possible to build your own collector which I think is overkill for what I needed it for here. I think I will explore this option in another blog post.</p><p>So this is the beginning of thinking of things in a functional way I guess as I think streams are a way of Java 8 trying to get in on the functional trend. They seem clear so far, but I think I have just scratched the surface! Next step, build my very own Collector...</p></div>
        </article>
        </li><li class="entries">
        <article>
        <header>
        <h2><a class="entries" data-id="page-link" href="static_variables.html">static variables</a></h2>
        <p class="date" data-id="published-at" data-format="dd MMMM yyyy">07 January 2016</p>
        </header>
        <div data-id="content"><p>A static method or vaiable is one that does not belong to a particular object but to a class. There are a few reasons for doing this. You may want to keep track of how many objects of a certain type ofe class are created, or assign an id to each object created or just access a variable from outside the class. It is possible to then access the static, constant from outside the class, but in order to make it unchangable it is necessary to also declare it final.</p><p>It is convention to write constants in capitals. They will still work as expected if this is not done, but doing this means that it is clear to anyone reading your code that the variable is a constant.</p><p>I have tended to avoid using constants, but I am going to try and introduce them wherever necessary in my Java TicTacToe.</p></div>
        </article>
        </li>
    </ol>
    <nav>
    <p class="previous" data-id="if-exists" data-key="prev"><a data-id="prev" data-set="attrs" href="readme-2.html">&lt;&lt; Previous</a></p>
    
    </nav>
    </main>
    <footer>
    <p>Site generated by <a href="http://www.pinaclj.com/">Pinaclj</a>.</p>
    </footer>
    <script src="prism.js"></script>
</body>

</html>