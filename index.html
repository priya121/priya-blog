<html>
    <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <link href="https://fonts.googleapis.com/css?family=PT+Serif:400,400italic,700,700italic" rel="stylesheet" type="text/css" />
    <link href="https://fonts.googleapis.com/css?family=Syncopate" rel="stylesheet" type="text/css" />
    <link type="text/css" rel="stylesheet" href="styles.css" />
    <link href="prism.css" rel="stylesheet" />
    <title data-id="blog-title">Priya’s Blog</title>
</head>

<body>

    <div class="nav">
        <ul>
            <li class="home"><a href="http://priya121.github.io/priyas-blog/index.html">Home</a></li>
            <!--li class="news"><a class="active" href="#">News</a></li-->
            <li class="old_blog"><a href="https://priyapatil101.wordpress.com/">MyOldBlog</a></li>
            <li class="100days"><a href="http://priya121.github.io/100days/">100days</a></li>
        </ul>
    </div>


    <header id="top">
    <h1><a href="index.html" data-id="blog-title">Priya’s Blog</a></h1>
    <ul>
        <li data-id="if-exists" data-key="twitter">
        <a href="https://twitter.com/priya104 " data-id="href" data-key="twitter">
            <img src="tw.png" width="24" height="20" />
        </a>
        </li>
        
    </ul>
    </header>


    <main>

    <ol class="entries" data-id="page-list" data-max-pages="5">
        <li class="entries">
        <article>
        <header>
        <h2><a class="entries" data-id="page-link" href="streams_two.html">Mapping through streams</a></h2>
        <p class="date" data-id="published-at" data-format="dd MMMM yyyy">29 January 2016</p>
        </header>
        <div data-id="content"><p>I’m not sure if you can actually say mapping through streams, but .map() is another useful intermediate operation you can use on the Stream class. Simple sequential streams using .stream() to create a list of elements are relatively straightforward and once you have filtered the data you want to act on, it is also quite simple to use the .map() operation to manipulate the data. .map() allows you to apply a function to elements in the stream.</p><p>Here is an example of this:</p><pre>
<code class="language-java">
Stream&lt;String&gt; map = names.stream()
        .filter(name -&gt; name.startsWith("p"))
                .map(String::toUpperCase);
</code>
</pre>
<p>In this example .map() converts each of the names starting with p in the list of names to a capital P.</p><p>As nothing has been explicitly returned yet, a terminal operation is neccesary, and here the .collect() operation can be used again.</p><pre>
<code class="language-java">
List&lt;String&gt; map = names.stream()
.filter(name -&gt; name.startsWith("p"))
.map(String::toUpperCase);
.collect(toList());
</code>
</pre>
<p>(Another useful way to map through a stream is to use .mapToInt(), which converts primitive ints to Integer objects, and .mapToObj() which converts primitives to Objects).</p><p>The syntax of streams looks a bit strange at the moment, but I suppose I’m just used to regular old for loops. I think I’m starting to see that the basic stream operations are actually relatively straightforward. I’m sure they are going to get much more complicated as I try and apply them more, but hopefully it’s just a case of getting used to the syntax and the way they look.</p></div>
        </article>
        </li><li class="entries">
        <article>
        <header>
        <h2><a class="entries" data-id="page-link" href="streams.html">Streams</a></h2>
        <p class="date" data-id="published-at" data-format="dd MMMM yyyy">28 January 2016</p>
        </header>
        <div data-id="content"><p>I started to introduce streams into my TicTacToe last week and even though the basic operations seem pretty straightforward, I need to understand the details of what is going on and so one of my stories this week is to write a series of blog posts on Java 8 Streams. So here it goes!</p><p>A stream represents a sequence of elements and there are a series of operations that can be performed on them. These operations can be intermediate (which require a terminal operation to be called after them) or terminal (which return a non-stream or void result).</p><p>Most stream operations accept a lambda expression as a parameter.</p><p>A lambda expression is a function which can exist without belonging to a class. They are similar to anonymous inner classes in Java (which are classes that do not have a class name and are instantiated and declared at the same time).</p><p>Here is an example of very simple a lambda expression:</p><p>(int x, int y) -&gt; x + y)</p><p>The expression is divided into three parts: The argument list, the arrow token and the body.</p><p>So, back to streams. A stream represents a list of object references, there are also streams that represent primitives like IntStream, DoubleStream, LongStream. Stream operations are chained together into pipelines.</p><p>The first stream I implemented was to repace the loop I had that checked the valid moves (represented by empty cells) on the board. Previously I was using this for loop to find all the empty cells on my board:</p><pre>
<code class="language-java">
public List&lt;Integer&gt; validMoves() {
        List&lt;Integer&gt; validMoves = new ArrayList&lt;Integer&gt;();
        for (int i = 0; i &lt; board.size(); i++) {
            if (board.get(i).equals(empty)) {
                            validMoves.add(i);
            }
        }
                return validMoves;
}
</code>
</pre>
<p>But I have now introduced this stream:</p><pre>
<code class="language-java">
public List&lt;Integer&gt; validMoves() {
    List&lt;Integer&gt; validMoves =
        IntStream.range(0, this.board.size()).boxed()
        .filter(index -&gt; this.board.get(index).equals(E))
        .collect(toList());
    return validMoves;
}
</code>
</pre>
<p>IntStream streams through a list of indices from 0 to the total size of the board. Calling .boxed() converts the IntStream into a Stream. .filter() then filters through the board and takes the arguement index and using a lambda expression applies it to the .get() method I have for my board.</p><p>Because this is an intermediate operation, without something following the .filter() nothing will be returned. This is why .collect(toList()) is needed. .collect() allows you to convert a stream into another type of result, in my case a list.</p><p>The operation .collect() accepts a Collector and there are many useful collectors, the one I have used is toList(), there are also many other useful ones like .groupingBy(), .averagingInt() etc. It is also possible to build your own collector which I think is overkill for what I needed it for here. I think I will explore this option in another blog post.</p><p>So this is the beginning of thinking of things in a functional way I guess as I think streams are a way of Java 8 trying to get in on the functional trend. They seem clear so far, but I think I have just scratched the surface! Next step, build my very own Collector...</p></div>
        </article>
        </li><li class="entries">
        <article>
        <header>
        <h2><a class="entries" data-id="page-link" href="static_variables.html">static variables</a></h2>
        <p class="date" data-id="published-at" data-format="dd MMMM yyyy">07 January 2016</p>
        </header>
        <div data-id="content"><p>A static method or vaiable is one that does not belong to a particular object but to a class. There are a few reasons for doing this. You may want to keep track of how many objects of a certain type ofe class are created, or assign an id to each object created or just access a variable from outside the class. It is possible to then access the static, constant from outside the class, but in order to make it unchangable it is necessary to also declare it final.</p><p>It is convention to write constants in capitals. They will still work as expected if this is not done, but doing this means that it is clear to anyone reading your code that the variable is a constant.</p><p>I have tended to avoid using constants, but I am going to try and introduce them wherever necessary in my Java TicTacToe.</p></div>
        </article>
        </li><li class="entries">
        <article>
        <header>
        <h2><a class="entries" data-id="page-link" href="trade-offs.html">trade offs</a></h2>
        <p class="date" data-id="published-at" data-format="dd MMMM yyyy">05 January 2016</p>
        </header>
        <div data-id="content"><p>So much in coding (and in life really!) is about trade offs. There are so many ways to do the same thing when you write code that most of the time there are a lot of advantages and disadvantages to a single approach.</p><p>I suppose that is why everyone in the coding community seems to be so opinionated about what they believe is the optimal way to do something. I am still forming my opinions about the tools and approaches I am learning. </p><p>I am sure once I learn the restrictions and frustrations of using a tool in a real world environment I’ll form some stronger opinions about what I prefer, but right now I can see the trade offs for most approaches and think you can probably find a use for most tools depending on the job.</p></div>
        </article>
        </li><li class="entries">
        <article>
        <header>
        <h2><a class="entries" data-id="page-link" href="heaps_and_stacks.html">Memory Management in Java</a></h2>
        <p class="date" data-id="published-at" data-format="dd MMMM yyyy">04 January 2016</p>
        </header>
        <div data-id="content"><p>Memory is something that seems pretty abstract before you face a real problem with it. Objects and data are stored on the Java Virtual Machine and when writing simple small programs, when and how these are created is not that important.</p><p>It becomes more important when lots of different classes interact and the order objects are created and destroyed affects the efficiency of a program.</p><p>Java has two areas of memory. The stack and the heap.</p><p>The stack is where variables live and they live on the stack frame where the method they belong to is stored. Object reference variables also are stored in this way.</p><p>All objects however, live on the heap so that they can be destroyed by the garbage collector when they are no longer needed (when there are no longer any live references to them). If your program starts to run low on memory, the garbage collector destroys the objects that are no longer needed and memory will not run out.</p><p>I am working on a longer blog post about testing in Vim for Java using Gradle and even though I’m sure I’ve just scratched the surface, hopefully understanding memory management will make understanding how threads and sockets work more clear.</p></div>
        </article>
        </li>
    </ol>
    <nav>
    <p class="previous" data-id="if-exists" data-key="prev"><a data-id="prev" data-set="attrs" href="index-2.html">&lt;&lt; Previous</a></p>
    
    </nav>
    </main>
    <footer>
    <p>Site generated by <a href="http://www.pinaclj.com/">Pinaclj</a>.</p>
    </footer>
    <script src="prism.js"></script>
</body>

</html>
