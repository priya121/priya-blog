<html>
    <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <link href="https://fonts.googleapis.com/css?family=PT+Serif:400,400italic,700,700italic" rel="stylesheet" type="text/css" />
    <link href="https://fonts.googleapis.com/css?family=Syncopate" rel="stylesheet" type="text/css" />
    <link type="text/css" rel="stylesheet" href="../../styles.css" />
    <link href="../../prism.css" rel="stylesheet" />
    <title data-id="blog-title">Priya’s Blog</title>
</head>

<body>

    <div class="nav">
        <ul>
            <li class="home"><a href="http://priya121.github.io/priyas-blog/index.html">Home</a></li>
            <li class="news"><a class="active" href="../../#">News</a></li>
            <li class="old_blog"><a href="https://priyapatil101.wordpress.com/">OldBlog</a></li>
            <li class="100days"><a href="http://priya121.github.io/100days/">100days</a></li>
        </ul>
    </div>


    <header id="top">
    <h1><a href="../../index.html" data-id="blog-title">Priya’s Blog</a></h1>
    <ul>
        <li data-id="if-exists" data-key="twitter">
        <a href="" data-id="href" data-key="twitter">
            <img src="../../tw.png" width="24" height="20" />
        </a>
        </li>
        
    </ul>
    </header>


    <main>

    <ol class="entries" data-id="page-list" data-max-pages="5">
        <li class="entries">
        <article>
        <header>
        <h2><a class="entries" data-id="page-link" href="../../trade-offs.html">trade offs</a></h2>
        <p class="date" data-id="published-at" data-format="dd MMMM yyyy">05 January 2016</p>
        </header>
        <div data-id="content"><p>So much in coding (and in life really!) is about trade offs. There are so many ways to do the same thing when you write code that most of the time there are a lot of advantages and disadvantages to a single approach.</p><p>I suppose that is why everyone in the coding community seems to be so opinionated about what they believe is the optimal way to do something. I am still forming my opinions about the tools and approaches I am learning. </p><p>I am sure once I learn the restrictions and frustrations of using a tool in a real world environment I’ll form some stronger opinions about what I prefer, but right now I can see the trade offs for most approaches and think you can probably find a use for most tools depending on the job.</p></div>
        </article>
        </li><li class="entries">
        <article>
        <header>
        <h2><a class="entries" data-id="page-link" href="../../static_variables.html">static variables</a></h2>
        <p class="date" data-id="published-at" data-format="dd MMMM yyyy">07 January 2016</p>
        </header>
        <div data-id="content"><p>A static method or vaiable is one that does not belong to a particular object but to a class. There are a few reasons for doing this. You may want to keep track of how many objects of a certain type ofe class are created, or assign an id to each object created or just access a variable from outside the class. It is possible to then access the static, constant from outside the class, but in order to make it unchangable it is necessary to also declare it final.</p><p>It is convention to write constants in capitals. They will still work as expected if this is not done, but doing this means that it is clear to anyone reading your code that the variable is a constant.</p><p>I have tended to avoid using constants, but I am going to try and introduce them wherever necessary in my Java TicTacToe.</p></div>
        </article>
        </li><li class="entries">
        <article>
        <header>
        <h2><a class="entries" data-id="page-link" href="../../streams.html">Streams</a></h2>
        <p class="date" data-id="published-at" data-format="dd MMMM yyyy">28 January 2016</p>
        </header>
        <div data-id="content"><p>I started to introduce streams into my TicTacToe last week and even though the basic operations seem pretty straightforward, I need to understand the details of what is going on and so one of my stories this week is to write a series of blog posts on Java 8 Streams. So here it goes!</p><p>A stream represents a sequence of elements and there are a series of operations that can be performed on them. These operations can be intermediate (which require a terminal operation to be called after them) or terminal (which return a non-stream or void result).</p><p>Most stream operations accept a lambda expression as a parameter.</p><p>A lambda expression is a function which can exist without belonging to a class. They are similar to anonymous inner classes in Java (which are classes that do not have a class name and are instantiated and declared at the same time).</p><p>Here is an example of very simple a lambda expression:</p><p>(int x, int y) -&gt; x + y)</p><p>The expression is divided into three parts: The argument list, the arrow token and the body.</p><p>So, back to streams. A stream represents a list of object references, there are also streams that represent primitives like IntStream, DoubleStream, LongStream. Stream operations are chained together into pipelines.</p><p>The first stream I implemented was to repace the loop I had that checked the valid moves (represented by empty cells) on the board. Previously I was using this for loop to find all the empty cells on my board:</p><pre>
<code class="language-java">
public List&lt;Integer&gt; validMoves() {
        List&lt;Integer&gt; validMoves = new ArrayList&lt;Integer&gt;();
        for (int i = 0; i &lt; board.size(); i++) {
            if (board.get(i).equals(empty)) {
                            validMoves.add(i);
            }
        }
                return validMoves;
}
</code>
</pre>
<p>But I have now introduced this stream:</p><pre>
<code class="language-java">
public List&lt;Integer&gt; validMoves() {
    List&lt;Integer&gt; validMoves =
        IntStream.range(0, this.board.size()).boxed()
        .filter(index -&gt; this.board.get(index).equals(E))
        .collect(toList());
    return validMoves;
}
</code>
</pre>
<p>IntStream streams through a list of indices from 0 to the total size of the board. Calling .boxed() converts the IntStream into a Stream. .filter() then filters through the board and takes the arguement index and using a lambda expression applies it to the .get() method I have for my board.</p><p>Because this is an intermediate operation, without something following the .filter() nothing will be returned. This is why .collect(toList()) is needed. .collect() allows you to convert a stream into another type of result, in my case a list.</p><p>The operation .collect() accepts a Collector and there are many useful collectors, the one I have used is toList(), there are also many other useful ones like .groupingBy(), .averagingInt() etc. It is also possible to build your own collector which I think is overkill for what I needed it for here. I think I will explore this option in another blog post.</p><p>So this is the beginning of thinking of things in a functional way I guess as I think streams are a way of Java 8 trying to get in on the functional trend. They seem clear so far, but I think I have just scratched the surface! Next step, build my very own Collector...</p></div>
        </article>
        </li><li class="entries">
        <article>
        <header>
        <h2><a class="entries" data-id="page-link" href="../../streams_two.html">Mapping through streams</a></h2>
        <p class="date" data-id="published-at" data-format="dd MMMM yyyy">29 January 2016</p>
        </header>
        <div data-id="content"><p>I’m not sure if you can actually say mapping through streams, but .map() is another useful intermediate operation you can use on the Stream class. Simple sequential streams using .stream() to create a list of elements are relatively straightforward and once you have filtered the data you want to act on, it is also quite simple to use the .map() operation to manipulate the data. .map() allows you to apply a function to elements in the stream.</p><p>Here is an example of this:</p><pre>
<code class="language-java">
Stream&lt;String&gt; map = names.stream()
        .filter(name -&gt; name.startsWith("p"))
                .map(String::toUpperCase);
</code>
</pre>
<p>In this example .map() converts each of the names starting with p in the list of names to a capital P.</p><p>As nothing has been explicitly returned yet, a terminal operation is neccesary, and here the .collect() operation can be used again.</p><pre>
<code class="language-java">
List&lt;String&gt; map = names.stream()
.filter(name -&gt; name.startsWith("p"))
.map(String::toUpperCase);
.collect(toList());
</code>
</pre>
<p>(Another useful way to map through a stream is to use .mapToInt(), which converts primitive ints to Integer objects, and .mapToObj() which converts primitives to Objects).</p><p>The syntax of streams looks a bit strange at the moment, but I suppose I’m just used to regular old for loops. I think I’m starting to see that the basic stream operations are actually relatively straightforward. I’m sure they are going to get much more complicated as I try and apply them more, but hopefully it’s just a case of getting used to the syntax and the way they look.</p></div>
        </article>
        </li><li class="entries">
        <article>
        <header>
        <h2><a class="entries" data-id="page-link" href="../../collecting_with_streams.html">Building a collection</a></h2>
        <p class="date" data-id="published-at" data-format="dd MMMM yyyy">01 February 2016</p>
        </header>
        <div data-id="content"><p>Woah, I just got a beast of an error message from my stream method and have no idea what it means. I suppose this is another disadvantage of using something new, when something goes wrong, it is harder to understand why at first.</p><p>Anyway, it wasn’t the streams fault, but something else in my code so crisis averted (kind of).</p><p>So I wanted to look at Collectors more today, starting by looking at the built in collectors and then maybe making my own.</p><p>Collectors are useful for creating a list out of the elements of a stream. I have already used .collect(toList()); quite a lot but some other really useful collectors are ones you can use for Integers:</p><pre>
 <code class="language-java">
      int total = groceries.stream()
                       .collect(Collectors.summingInt(GroceryItem::getPrice)));
</code> 
</pre>
<p>There is also .counting() that increments by the number of input elements, and .averagingInt() that like .summingInt() above aggregates the elements and then performs the operation sequentially on them, this time returning the average of the elements. These operations are also available for Doubles and Longs.</p><p>.joining() concatenates the elements into a String in the order they are processed and can take a delimiter (how the elements are joined together), a prefix and a suffix as arguments. If you don’t give a prefix and suffix the only arguement required is the delimiter.</p><pre>
 <code class="language-java">
     String invitation = guests.stream()
      .filter(p -&gt; p.address == "18 Cedar Way")
      .map(p -&gt; p.name)
      .collect(Collectors.joining(" and ", "Hi ", "! You are invited to the party.);
 </code> 
</pre>
<p>This would produce: Hi, Luda and Tom! You are invited to the party.  (Assuming Luda and Tom were two of the Person objects within the Stream of guests, each having instance variables of an address and name).</p><p><a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Collectors.html#toMap-java.util.function.Function-java.util.function.Function-">.toMap()</a> is another useful one that allows you to change the elements of the stream into a map.</p><p>All of these collectors are predefined but it is possible to build your own collector using Collector.of() These take a supplier, combiner, accumulator and finsher.</p><p>The interface of a Collector starts with Collector&lt;T, A, R&gt;:</p><p>This means a Collector accepts items of type T and produces aggregated/accumulated (A) values of the return type R.</p><p>Here is an example:</p><pre>
 <code class="language-java">
   Collector&lt;Guest, StringJoiner, String&gt; guestList =
    Collector.of(
         () -&gt; new StringJoiner(" , "),
         (list, guest) -&gt; list.add(guest.name),
         (list1, list2) -&gt; list1.merge(list2),
         StringJoiner::toString);
</code> 
</pre>
<p>The first part (the supplier) of this Collector is the supplier that creates a new immutable set, which is an unchangeable list of unique elements.</p><p>The second part (the accumulator) of this is the supplier that takes an element of the type T and joins it to the immutable set (the new StringJoiner(“ , “)) it’s called list here.</p><p>The third part (the combiner) joins or merges the elements together one by one.</p><p>Finally the fourth part (the finisher) returns the immutable set as the return type you specify.</p><p>If names is returned within a function it should produce a list of names of the Guest objects as a String, joined by a comma.</p><pre>
  <code class="language-java">
   String names = guests
.stream()
    .collect(guestList);
</code> 
</pre>
<p>So that is how you build your own collection. There are also .flatmap() and .reduce() which I should probably look into, but not I have put off integrating streams into my TicTacToe when determining rows and columns enough so should probably do that first.</p></div>
        </article>
        </li>
    </ol>
    <nav>
    
    <p class="next" data-id="if-exists" data-key="next"><a data-id="next" data-set="attrs" href="../../category/post/index-15.html">Next &gt;&gt;</a></p>
    </nav>
    </main>
    <footer>
    <p>Site generated by <a href="http://www.pinaclj.com/">Pinaclj</a>.</p>
    </footer>
    <script src="../../prism.js"></script>
</body>

</html>